**ã€Šä»£ç éšæƒ³å½•ã€‹ç®—æ³•è§†é¢‘å…¬å¼€è¯¾ï¼š[Leetcode:39. ç»„åˆæ€»å’Œè®²è§£](https://www.bilibili.com/video/BV1KT4y1M7HJ)ï¼Œç›¸ä¿¡ç»“åˆè§†é¢‘å†çœ‹æœ¬ç¯‡é¢˜è§£ï¼Œæ›´æœ‰åŠ©äºå¤§å®¶å¯¹æœ¬é¢˜çš„ç†è§£**ã€‚

# æ€è·¯

é¢˜ç›®ä¸­çš„**æ— é™åˆ¶é‡å¤è¢«é€‰å–ï¼Œå“å¾—æˆ‘èµ¶ç´§æƒ³æƒ³ å‡ºç°0 å¯å’‹åŠ**ï¼Œç„¶åçœ‹åˆ°ä¸‹é¢æç¤ºï¼š1 <= candidates[i] <= 200ï¼Œæˆ‘å°±æ”¾å¿ƒäº†ã€‚

æœ¬é¢˜å’Œ[77.ç»„åˆ](https://programmercarl.com/0077.ç»„åˆ.html)ï¼Œ[216.ç»„åˆæ€»å’ŒIII](https://programmercarl.com/0216.ç»„åˆæ€»å’ŒIII.html)çš„åŒºåˆ«æ˜¯ï¼šæœ¬é¢˜æ²¡æœ‰æ•°é‡è¦æ±‚ï¼Œå¯ä»¥æ— é™é‡å¤ï¼Œä½†æ˜¯æœ‰æ€»å’Œçš„é™åˆ¶ï¼Œæ‰€ä»¥é—´æ¥çš„ä¹Ÿæ˜¯æœ‰ä¸ªæ•°çš„é™åˆ¶ã€‚

æœ¬é¢˜æœç´¢çš„è¿‡ç¨‹æŠ½è±¡æˆæ ‘å½¢ç»“æ„å¦‚ä¸‹ï¼š

![image.png](https://pic.leetcode.cn/1671682581-cfPEKy-image.png)

æ³¨æ„å›¾ä¸­å¶å­èŠ‚ç‚¹çš„è¿”å›æ¡ä»¶ï¼Œå› ä¸ºæœ¬é¢˜æ²¡æœ‰ç»„åˆæ•°é‡è¦æ±‚ï¼Œä»…ä»…æ˜¯æ€»å’Œçš„é™åˆ¶ï¼Œæ‰€ä»¥é€’å½’æ²¡æœ‰å±‚æ•°çš„é™åˆ¶ï¼Œåªè¦é€‰å–çš„å…ƒç´ æ€»å’Œè¶…è¿‡targetï¼Œå°±è¿”å›ï¼

è€Œåœ¨[77.ç»„åˆ](https://programmercarl.com/0077.ç»„åˆ.html)å’Œ[216.ç»„åˆæ€»å’ŒIII](https://programmercarl.com/0216.ç»„åˆæ€»å’ŒIII.html) ä¸­éƒ½å¯ä»¥çŸ¥é“è¦é€’å½’Kå±‚ï¼Œå› ä¸ºè¦å–kä¸ªå…ƒç´ çš„ç»„åˆã€‚

## å›æº¯ä¸‰éƒ¨æ›²

* é€’å½’å‡½æ•°å‚æ•°

è¿™é‡Œä¾ç„¶æ˜¯å®šä¹‰ä¸¤ä¸ªå…¨å±€å˜é‡ï¼ŒäºŒç»´æ•°ç»„resultå­˜æ”¾ç»“æœé›†ï¼Œæ•°ç»„pathå­˜æ”¾ç¬¦åˆæ¡ä»¶çš„ç»“æœã€‚ï¼ˆè¿™ä¸¤ä¸ªå˜é‡å¯ä»¥ä½œä¸ºå‡½æ•°å‚æ•°ä¼ å…¥ï¼‰

é¦–å…ˆæ˜¯é¢˜ç›®ä¸­ç»™å‡ºçš„å‚æ•°ï¼Œé›†åˆcandidates, å’Œç›®æ ‡å€¼targetã€‚

æ­¤å¤–æˆ‘è¿˜å®šä¹‰äº†intå‹çš„sumå˜é‡æ¥ç»Ÿè®¡å•ä¸€ç»“æœpathé‡Œçš„æ€»å’Œï¼Œå…¶å®è¿™ä¸ªsumä¹Ÿå¯ä»¥ä¸ç”¨ï¼Œç”¨targetåšç›¸åº”çš„å‡æ³•å°±å¯ä»¥äº†ï¼Œæœ€åå¦‚ä½•target==0å°±è¯´æ˜æ‰¾åˆ°ç¬¦åˆçš„ç»“æœäº†ï¼Œä½†ä¸ºäº†ä»£ç é€»è¾‘æ¸…æ™°ï¼Œæˆ‘ä¾ç„¶ç”¨äº†sumã€‚

**æœ¬é¢˜è¿˜éœ€è¦startIndexæ¥æ§åˆ¶forå¾ªç¯çš„èµ·å§‹ä½ç½®ï¼Œå¯¹äºç»„åˆé—®é¢˜ï¼Œä»€ä¹ˆæ—¶å€™éœ€è¦startIndexå‘¢ï¼Ÿ**

æˆ‘ä¸¾è¿‡ä¾‹å­ï¼Œå¦‚æœæ˜¯ä¸€ä¸ªé›†åˆæ¥æ±‚ç»„åˆçš„è¯ï¼Œå°±éœ€è¦startIndexï¼Œä¾‹å¦‚ï¼š[77.ç»„åˆ](https://programmercarl.com/0077.ç»„åˆ.html)ï¼Œ[216.ç»„åˆæ€»å’ŒIII](https://programmercarl.com/0216.ç»„åˆæ€»å’ŒIII.html)ã€‚

å¦‚æœæ˜¯å¤šä¸ªé›†åˆå–ç»„åˆï¼Œå„ä¸ªé›†åˆä¹‹é—´ç›¸äº’ä¸å½±å“ï¼Œé‚£ä¹ˆå°±ä¸ç”¨startIndexï¼Œä¾‹å¦‚ï¼š[17.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](https://programmercarl.com/0017.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ.html)

**æ³¨æ„ä»¥ä¸Šæˆ‘åªæ˜¯è¯´æ±‚ç»„åˆçš„æƒ…å†µï¼Œå¦‚æœæ˜¯æ’åˆ—é—®é¢˜ï¼Œåˆæ˜¯å¦ä¸€å¥—åˆ†æçš„å¥—è·¯ï¼Œåé¢æˆ‘å†è®²è§£æ’åˆ—çš„æ—¶å€™å°±é‡ç‚¹ä»‹ç»**ã€‚

ä»£ç å¦‚ä¸‹ï¼š

* CPP

```CPP
vector<vector<int>> result;
vector<int> path;
void backtracking(vector<int>& candidates, int target, int sum, int startIndex)
```

* é€’å½’ç»ˆæ­¢æ¡ä»¶

åœ¨å¦‚ä¸‹æ ‘å½¢ç»“æ„ä¸­ï¼š

![image.png](https://pic.leetcode.cn/1671682625-TtedXP-image.png)

ä»å¶å­èŠ‚ç‚¹å¯ä»¥æ¸…æ™°çœ‹åˆ°ï¼Œç»ˆæ­¢åªæœ‰ä¸¤ç§æƒ…å†µï¼Œsumå¤§äºtargetå’Œsumç­‰äºtargetã€‚

sumç­‰äºtargetçš„æ—¶å€™ï¼Œéœ€è¦æ”¶é›†ç»“æœï¼Œä»£ç å¦‚ä¸‹ï¼š

* CPP

```CPP
if (sum > target) {
    return;
}
if (sum == target) {
    result.push_back(path);
    return;
}
```

* å•å±‚æœç´¢çš„é€»è¾‘

å•å±‚forå¾ªç¯ä¾ç„¶æ˜¯ä»startIndexå¼€å§‹ï¼Œæœç´¢candidatesé›†åˆã€‚

**æ³¨æ„æœ¬é¢˜å’Œ[77.ç»„åˆ](https://programmercarl.com/0077.ç»„åˆ.html)ã€[216.ç»„åˆæ€»å’ŒIII](https://programmercarl.com/0216.ç»„åˆæ€»å’ŒIII.html)çš„ä¸€ä¸ªåŒºåˆ«æ˜¯ï¼šæœ¬é¢˜å…ƒç´ ä¸ºå¯é‡å¤é€‰å–çš„**ã€‚

å¦‚ä½•é‡å¤é€‰å–å‘¢ï¼Œçœ‹ä»£ç ï¼Œæ³¨é‡Šéƒ¨åˆ†ï¼š

* CPP

```CPP
for (int i = startIndex; i < candidates.size(); i++) {
    sum += candidates[i];
    path.push_back(candidates[i]);
    backtracking(candidates, target, sum, i); // å…³é”®ç‚¹:ä¸ç”¨i+1äº†ï¼Œè¡¨ç¤ºå¯ä»¥é‡å¤è¯»å–å½“å‰çš„æ•°
    sum -= candidates[i];   // å›æº¯
    path.pop_back();        // å›æº¯
}
```

æŒ‰ç…§[å…³äºå›æº¯ç®—æ³•ï¼Œä½ è¯¥äº†è§£è¿™äº›ï¼](https://programmercarl.com/å›æº¯ç®—æ³•ç†è®ºåŸºç¡€.html)ä¸­ç»™å‡ºçš„æ¨¡æ¿ï¼Œä¸éš¾å†™å‡ºå¦‚ä¸‹C++å®Œæ•´ä»£ç ï¼š

* CPP

```CPP
// ç‰ˆæœ¬ä¸€
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {
        if (sum > target) {
            return;
        }
        if (sum == target) {
            result.push_back(path);
            return;
        }

        for (int i = startIndex; i < candidates.size(); i++) {
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum, i); // ä¸ç”¨i+1äº†ï¼Œè¡¨ç¤ºå¯ä»¥é‡å¤è¯»å–å½“å‰çš„æ•°
            sum -= candidates[i];
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        result.clear();
        path.clear();
        backtracking(candidates, target, 0, 0);
        return result;
    }
};
```

## å‰ªæä¼˜åŒ–

åœ¨è¿™ä¸ªæ ‘å½¢ç»“æ„ä¸­ï¼š

![image.png](https://pic.leetcode.cn/1671682670-XpzLHA-image.png)

ä»¥åŠä¸Šé¢çš„ç‰ˆæœ¬ä¸€çš„ä»£ç å¤§å®¶å¯ä»¥çœ‹åˆ°ï¼Œå¯¹äºsumå·²ç»å¤§äºtargetçš„æƒ…å†µï¼Œå…¶å®æ˜¯ä¾ç„¶è¿›å…¥äº†ä¸‹ä¸€å±‚é€’å½’ï¼Œåªæ˜¯ä¸‹ä¸€å±‚é€’å½’ç»“æŸåˆ¤æ–­çš„æ—¶å€™ï¼Œä¼šåˆ¤æ–­sum > targetçš„è¯å°±è¿”å›ã€‚

å…¶å®å¦‚æœå·²ç»çŸ¥é“ä¸‹ä¸€å±‚çš„sumä¼šå¤§äºtargetï¼Œå°±æ²¡æœ‰å¿…è¦è¿›å…¥ä¸‹ä¸€å±‚é€’å½’äº†ã€‚

é‚£ä¹ˆå¯ä»¥åœ¨forå¾ªç¯çš„æœç´¢èŒƒå›´ä¸Šåšåšæ–‡ç« äº†ã€‚

**å¯¹æ€»é›†åˆæ’åºä¹‹åï¼Œå¦‚æœä¸‹ä¸€å±‚çš„sumï¼ˆå°±æ˜¯æœ¬å±‚çš„ sum + candidates[i]ï¼‰å·²ç»å¤§äºtargetï¼Œå°±å¯ä»¥ç»“æŸæœ¬è½®forå¾ªç¯çš„éå†**ã€‚

å¦‚å›¾ï¼š

![image.png](https://pic.leetcode.cn/1671682701-KFMMNi-image.png)

forå¾ªç¯å‰ªæä»£ç å¦‚ä¸‹ï¼š

* 

```
for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)
```

æ•´ä½“ä»£ç å¦‚ä¸‹ï¼šï¼ˆæ³¨æ„æ³¨é‡Šçš„éƒ¨åˆ†ï¼‰

* CPP

```CPP
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {
        if (sum == target) {
            result.push_back(path);
            return;
        }

        // å¦‚æœ sum + candidates[i] > target å°±ç»ˆæ­¢éå†
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum, i);
            sum -= candidates[i];
            path.pop_back();

        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        result.clear();
        path.clear();
        sort(candidates.begin(), candidates.end()); // éœ€è¦æ’åº
        backtracking(candidates, target, 0, 0);
        return result;
    }
};
```

# æ€»ç»“

æœ¬é¢˜å’Œæˆ‘ä»¬ä¹‹å‰è®²è¿‡çš„[77.ç»„åˆ](https://programmercarl.com/0077.ç»„åˆ.html)ã€[216.ç»„åˆæ€»å’ŒIII](https://programmercarl.com/0216.ç»„åˆæ€»å’ŒIII.html)æœ‰ä¸¤ç‚¹ä¸åŒï¼š

* ç»„åˆæ²¡æœ‰æ•°é‡è¦æ±‚
* å…ƒç´ å¯æ— é™é‡å¤é€‰å–

é’ˆå¯¹è¿™ä¸¤ä¸ªé—®é¢˜ï¼Œæˆ‘éƒ½åšäº†è¯¦ç»†çš„åˆ†æã€‚

å¹¶ä¸”ç»™å‡ºäº†å¯¹äºç»„åˆé—®é¢˜ï¼Œä»€ä¹ˆæ—¶å€™ç”¨startIndexï¼Œä»€ä¹ˆæ—¶å€™ä¸ç”¨ï¼Œå¹¶ç”¨[17.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](https://programmercarl.com/0017.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ.html)åšäº†å¯¹æ¯”ã€‚

æœ€åè¿˜ç»™å‡ºäº†æœ¬é¢˜çš„å‰ªæä¼˜åŒ–ï¼Œè¿™ä¸ªä¼˜åŒ–å¦‚æœæ˜¯åˆå­¦è€…çš„è¯å¹¶ä¸å®¹æ˜“æƒ³åˆ°ã€‚

**åœ¨æ±‚å’Œé—®é¢˜ä¸­ï¼Œæ’åºä¹‹ååŠ å‰ªææ˜¯å¸¸è§çš„å¥—è·¯ï¼**

å¯ä»¥çœ‹å‡ºæˆ‘å†™çš„æ–‡ç« éƒ½ä¼šå¤§é‡å¼•ç”¨ä¹‹å‰çš„æ–‡ç« ï¼Œå°±æ˜¯è¦ä¸æ–­ä½œå¯¹æ¯”ï¼Œåˆ†æå…¶å·®å¼‚ï¼Œç„¶åç»™å‡ºä»£ç è§£å†³çš„æ–¹æ³•ï¼Œè¿™æ ·æ‰èƒ½å½»åº•ç†è§£é¢˜ç›®çš„æœ¬è´¨ä¸éš¾ç‚¹ã€‚

# å…¶ä»–è¯­è¨€ç‰ˆæœ¬

* []

```Java
// å‰ªæä¼˜åŒ–
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(candidates); // å…ˆè¿›è¡Œæ’åº
        backtracking(res, new ArrayList<>(), candidates, target, 0, 0);
        return res;
    }

    public void backtracking(List<List<Integer>> res, List<Integer> path, int[] candidates, int target, int sum, int idx) {
        // æ‰¾åˆ°äº†æ•°å­—å’Œä¸º target çš„ç»„åˆ
        if (sum == target) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = idx; i < candidates.length; i++) {
            // å¦‚æœ sum + candidates[i] > target å°±ç»ˆæ­¢éå†
            if (sum + candidates[i] > target) break;
            path.add(candidates[i]);
            backtracking(res, path, candidates, target, sum + candidates[i], i);
            path.remove(path.size() - 1); // å›æº¯ï¼Œç§»é™¤è·¯å¾„ path æœ€åä¸€ä¸ªå…ƒç´ 
        }
    }
}
```

* []

```python
# **å›æº¯**
class Solution:
    def __init__(self):
        self.path = []
        self.paths = []

    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        '''
        å› ä¸ºæœ¬é¢˜æ²¡æœ‰ç»„åˆæ•°é‡é™åˆ¶ï¼Œæ‰€ä»¥åªè¦å…ƒç´ æ€»å’Œå¤§äºtargetå°±ç®—ç»“æŸ
        '''
        self.path.clear()
        self.paths.clear()
        self.backtracking(candidates, target, 0, 0)
        return self.paths

    def backtracking(self, candidates: List[int], target: int, sum_: int, start_index: int) -> None:
        # Base Case
        if sum_ == target:
            self.paths.append(self.path[:]) # å› ä¸ºæ˜¯shallow copyï¼Œæ‰€ä»¥ä¸èƒ½ç›´æ¥ä¼ å…¥self.path
            return
        if sum_ > target:
            return 
        
        # å•å±‚é€’å½’é€»è¾‘ 
        for i in range(start_index, len(candidates)):
            sum_ += candidates[i]
            self.path.append(candidates[i])
            self.backtracking(candidates, target, sum_, i)  # å› ä¸ºæ— é™åˆ¶é‡å¤é€‰å–ï¼Œæ‰€ä»¥ä¸æ˜¯i+1
            sum_ -= candidates[i]   # å›æº¯
            self.path.pop()        # å›æº¯

# **å‰ªæå›æº¯**
class Solution:
    def __init__(self):
        self.path = []
        self.paths = []

    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        '''
        å› ä¸ºæœ¬é¢˜æ²¡æœ‰ç»„åˆæ•°é‡é™åˆ¶ï¼Œæ‰€ä»¥åªè¦å…ƒç´ æ€»å’Œå¤§äºtargetå°±ç®—ç»“æŸ
        '''
        self.path.clear()
        self.paths.clear()

        # ä¸ºäº†å‰ªæéœ€è¦æå‰è¿›è¡Œæ’åº
        candidates.sort()
        self.backtracking(candidates, target, 0, 0)
        return self.paths

    def backtracking(self, candidates: List[int], target: int, sum_: int, start_index: int) -> None:
        # Base Case
        if sum_ == target:
            self.paths.append(self.path[:]) # å› ä¸ºæ˜¯shallow copyï¼Œæ‰€ä»¥ä¸èƒ½ç›´æ¥ä¼ å…¥self.path
            return
        # å•å±‚é€’å½’é€»è¾‘ 
        # å¦‚æœæœ¬å±‚ sum + condidates[i] > targetï¼Œå°±æå‰ç»“æŸéå†ï¼Œå‰ªæ
        for i in range(start_index, len(candidates)):
            if sum_ + candidates[i] > target: 
                return 
            sum_ += candidates[i]
            self.path.append(candidates[i])
            self.backtracking(candidates, target, sum_, i)  # å› ä¸ºæ— é™åˆ¶é‡å¤é€‰å–ï¼Œæ‰€ä»¥ä¸æ˜¯i-1
            sum_ -= candidates[i]   # å›æº¯
            self.path.pop()        # å›æº¯
```

* []

```go
// ä¸»è¦åœ¨äºé€’å½’ä¸­ä¼ é€’ä¸‹ä¸€ä¸ªæ•°å­—
var (
    res [][]int
    path  []int
)
func combinationSum(candidates []int, target int) [][]int {
    res, path = make([][]int, 0), make([]int, 0, len(candidates))
    sort.Ints(candidates)   // æ’åºï¼Œä¸ºå‰ªæåšå‡†å¤‡
    dfs(candidates, 0, target)
    return res
}

func dfs(candidates []int, start int, target int) {
    if target == 0 {   // target ä¸æ–­å‡å°ï¼Œå¦‚æœä¸º0è¯´æ˜è¾¾åˆ°äº†ç›®æ ‡å€¼
        tmp := make([]int, len(path))
        copy(tmp, path)
        res = append(res, tmp)
        return
    }
    for i := start; i < len(candidates); i++ {
        if candidates[i] > target {  // å‰ªæï¼Œæå‰è¿”å›
            break
        }
        path = append(path, candidates[i])
        dfs(candidates, i, target - candidates[i])
        path = path[:len(path) - 1]
    }
}
```

* []

```js
var combinationSum = function(candidates, target) {
    const res = [], path = [];
    candidates.sort((a,b)=>a-b); // æ’åº
    backtracking(0, 0);
    return res;
    function backtracking(j, sum) {
        if (sum === target) {
            res.push(Array.from(path));
            return;
        }
        for(let i = j; i < candidates.length; i++ ) {
            const n = candidates[i];
            if(n > target - sum) break;
            path.push(n);
            sum += n;
            backtracking(i, sum);
            path.pop();
            sum -= n;
        }
    }
};
```

* []

```typescript
function combinationSum(candidates: number[], target: number): number[][] {
    const resArr: number[][] = [];
    function backTracking(
        candidates: number[], target: number,
        startIndex: number, route: number[], curSum: number
    ): void {
        if (curSum > target) return;
        if (curSum === target) {
            resArr.push(route.slice());
            return
        }
        for (let i = startIndex, length = candidates.length; i < length; i++) {
            let tempVal: number = candidates[i];
            route.push(tempVal);
            backTracking(candidates, target, i, route, curSum + tempVal);
            route.pop();
        }
    }
    backTracking(candidates, target, 0, [], 0);
    return resArr;
};
```

* []

```Rust
impl Solution {
    pub fn backtracking(result: &mut Vec<Vec<i32>>, path: &mut Vec<i32>, candidates: &Vec<i32>, target: i32, mut sum: i32, start_index: usize) {
        if sum == target { 
            result.push(path.to_vec());
            return;
        }
        for i in start_index..candidates.len() {
            if sum + candidates[i] <= target {
                sum += candidates[i];
                path.push(candidates[i]);
                Self::backtracking(result, path, candidates, target, sum, i);
                sum -= candidates[i];
                path.pop();
            }
        }
    }

    pub fn combination_sum(candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {
        let mut result: Vec<Vec<i32>> = Vec::new();
        let mut path: Vec<i32> = Vec::new();
        Self::backtracking(&mut result, &mut path, &candidates, target, 0, 0);
        result
    }
}
```

* []

```c
int* path;
int pathTop;
int** ans;
int ansTop;
//è®°å½•æ¯ä¸€ä¸ªå’Œç­‰äºtargetçš„pathæ•°ç»„é•¿åº¦
int* length;

void backTracking(int target, int index, int* candidates, int candidatesSize, int sum) {
    //è‹¥sum>=targetå°±åº”è¯¥ç»ˆæ­¢éå†
    if(sum >= target) {
        //è‹¥sumç­‰äºtargetï¼Œå°†å½“å‰çš„ç»„åˆæ”¾å…¥ansæ•°ç»„ä¸­
        if(sum == target) {
            int* tempPath = (int*)malloc(sizeof(int) * pathTop);
            int j;
            for(j = 0; j < pathTop; j++) {
                tempPath[j] = path[j];
            }
            ans[ansTop] = tempPath;
            length[ansTop++] = pathTop;
        }
        return ;
    }

    int i;
    for(i = index; i < candidatesSize; i++) {
        //å°†å½“å‰æ•°å­—å¤§å°åŠ å…¥sum
        sum+=candidates[i];
        path[pathTop++] = candidates[i];
        backTracking(target, i, candidates, candidatesSize, sum);
        sum-=candidates[i];
        pathTop--;
    }
}

int** combinationSum(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){
    //åˆå§‹åŒ–å˜é‡
    path = (int*)malloc(sizeof(int) * 50);
    ans = (int**)malloc(sizeof(int*) * 200);
    length = (int*)malloc(sizeof(int) * 200);
    ansTop = pathTop = 0;
    backTracking(target, 0, candidates, candidatesSize, 0);

    //è®¾ç½®è¿”å›çš„æ•°ç»„å¤§å°
    *returnSize = ansTop;
    *returnColumnSizes = (int*)malloc(sizeof(int) * ansTop);
    int i;
    for(i = 0; i < ansTop; i++) {
        (*returnColumnSizes)[i] = length[i];
    }
    return ans;
}
```

* []

```swift
func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {
    var result = [[Int]]()
    var path = [Int]()
    func backtracking(sum: Int, startIndex: Int) {
        // ç»ˆæ­¢æ¡ä»¶
        if sum == target {
            result.append(path)
            return
        }

        let end = candidates.count
        guard startIndex < end else { return }
        for i in startIndex ..< end {
            let sum = sum + candidates[i] // ä½¿ç”¨å±€éƒ¨å˜é‡éšè—å›æº¯
            if sum > target { continue } // å‰ªæ

            path.append(candidates[i]) // å¤„ç†
            backtracking(sum: sum, startIndex: i) // iä¸ç”¨+1ä»¥é‡å¤è®¿é—®
            path.removeLast() // å›æº¯
        }
    }
    backtracking(sum: 0, startIndex: 0)
    return result
}
```

* []

```scala
object Solution {
  import scala.collection.mutable
  def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
    var result = mutable.ListBuffer[List[Int]]()
    var path = mutable.ListBuffer[Int]()

    def backtracking(sum: Int, index: Int): Unit = {
      if (sum == target) {
        result.append(path.toList) // å¦‚æœæ­£å¥½ç­‰äºtargetï¼Œå°±æ·»åŠ åˆ°ç»“æœé›†
        return
      }
      // åº”è¯¥æ˜¯ä»å½“å‰ç´¢å¼•å¼€å§‹çš„ï¼Œè€Œä¸æ˜¯ä»0
      // å‰ªæä¼˜åŒ–ï¼šæ·»åŠ å¾ªç¯å®ˆå«ï¼Œå½“sum + c(i) <= targetçš„æ—¶å€™æ‰å¾ªç¯ï¼Œæ‰å¯ä»¥è¿›å…¥ä¸‹ä¸€æ¬¡é€’å½’
      for (i <- index until candidates.size if sum + candidates(i) <= target) {
        path.append(candidates(i))
        backtracking(sum + candidates(i), i)
        path = path.take(path.size - 1)
      }
    }

    backtracking(0, 0)
    result.toList
  }
}
```

# å›æº¯ç®—æ³•åŠ›æ‰£é¢˜ç›®æ€»ç»“

æŒ‰ç…§å¦‚ä¸‹é¡ºåºåˆ·åŠ›æ‰£ä¸Šçš„é¢˜ç›®ï¼Œç›¸ä¿¡ä¼šå¸®ä½ åœ¨å­¦ä¹ å›æº¯ç®—æ³•çš„è·¯ä¸Šå°‘èµ°å¾ˆå¤šå¼¯è·¯ã€‚

* [å…³äºå›æº¯ç®—æ³•ï¼Œä½ è¯¥äº†è§£è¿™äº›ï¼](https://programmercarl.com/å›æº¯ç®—æ³•ç†è®ºåŸºç¡€.html)
* ç»„åˆé—®é¢˜
  * [77.ç»„åˆ](https://programmercarl.com/0077.ç»„åˆ.html)
  * [216.ç»„åˆæ€»å’ŒIII](https://programmercarl.com/0216.ç»„åˆæ€»å’ŒIII.html)
  * [17.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](https://programmercarl.com/0017.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ.html)
  * [39.ç»„åˆæ€»å’Œ](https://programmercarl.com/0039.ç»„åˆæ€»å’Œ.html)
  * [40.ç»„åˆæ€»å’ŒII](https://programmercarl.com/0040.ç»„åˆæ€»å’ŒII.html)
* åˆ†å‰²é—®é¢˜
  * [131.åˆ†å‰²å›æ–‡ä¸²](https://programmercarl.com/0131.åˆ†å‰²å›æ–‡ä¸².html)
  * [93.å¤åŸIPåœ°å€](https://programmercarl.com/0093.å¤åŸIPåœ°å€.html)
* å­é›†é—®é¢˜
  * [78.å­é›†](https://programmercarl.com/0078.å­é›†.html)
  * [90.å­é›†II](https://programmercarl.com/0090.å­é›†II.html)
* æ’åˆ—é—®é¢˜
  * [46.å…¨æ’åˆ—](https://programmercarl.com/0046.å…¨æ’åˆ—.html)
  * [47.å…¨æ’åˆ—II](https://programmercarl.com/0047.å…¨æ’åˆ—II.html)
* æ£‹ç›˜é—®é¢˜
  * [51.Nçš‡å](https://programmercarl.com/0051.Nçš‡å.html)
  * [37.è§£æ•°ç‹¬](https://programmercarl.com/0037.è§£æ•°ç‹¬.html)
* å…¶ä»–
  * [491.é€’å¢å­åºåˆ—](https://programmercarl.com/0491.é€’å¢å­åºåˆ—.html)
  * [332.é‡æ–°å®‰æ’è¡Œç¨‹](https://programmercarl.com/0332.é‡æ–°å®‰æ’è¡Œç¨‹.html)
* [å›æº¯ç®—æ³•æ€»ç»“ç¯‡](https://programmercarl.com/å›æº¯æ€»ç»“.html)

-----------

å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯ç¨‹åºå‘˜Carlï¼Œå¦‚æœä½ è¿˜åœ¨æ²¡æœ‰ç« æ³•çš„åˆ·é¢˜ï¼Œ**å»ºè®®æŒ‰ç…§[ä»£ç éšæƒ³å½•åˆ·é¢˜è·¯çº¿](https://programmercarl.com/)æ¥åˆ·**ï¼Œå¹¶æä¾›[PDFä¸‹è½½](https://programmercarl.com/other/algo_pdf.html)ï¼Œåˆ·é¢˜è·¯çº¿åŒæ—¶ä¹Ÿå¼€æºåœ¨[Github](https://github.com/youngyangyang04/leetcode-master)ä¸Šï¼Œä½ ä¼šå‘ç°è¯¦è§å¾ˆæ™šï¼

**å¦‚æœæ„Ÿè§‰é¢˜è§£å¯¹ä½ æœ‰å¸®åŠ©ï¼Œä¸è¦åå•¬ç»™ä¸€ä¸ªğŸ‘å§ï¼**

