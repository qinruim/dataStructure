本题解只解释了[官方题解](https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution/)方法一，题解方法二和方法三不在我能解释的范围内，官方题解已经写得足够清楚，欢迎大家围观。我这里也是写点学习体会，欢迎大家指正。

补充：方法二和方法三，视情况掌握和理解，方法二官方写得非常具体了，所以我没有可以补充的地方。方法三官方说不具有一般性，我个人觉得没有必要掌握，看一下就好。

题目意思没有看懂的朋友，建议先看李永乐老师的视频：[《复工复产找工作？先来看看这道面试题：双蛋问题》](https://www.bilibili.com/video/BV1KE41137PK?from=search&seid=17973611971894816621)（建议关掉弹幕，要不然得笑晕过去），我下面也会解释，我也是从这个视频里理解到题目的意思的。

### 解释题意

+ 题目中「移动」的意思是：做一次实验，把一个鸡蛋从某个楼层扔下去，看它是否破碎。**没有破碎的鸡蛋可以重复使用**；
+ 这 `K` 个鸡蛋，`F` 值满足的特点是：
  + 在所有小于等于 `F` 的楼层扔下它不破碎；
  + 在所有大于 `F` 的楼层扔下它一定会破碎；
  + 所有鸡蛋的 `F` 值都一样，且确定的，并且 `0 <= F <= N`，即 `F` 值一定不会超过楼层高度。
+ `F`值是确定的，但它不是题目要我们求的。题目要我们求的是找到这个 `F` 值的最小实验次数。这其实是时间复杂度的概念，时间复杂度是在最坏情况下（即运气最差的情况下），程序执行完毕最少执行的次数，例如：
  + 在一个数组（长度为 $N$）里查找一个数，找到某个数可以用线性查找，最好情况下，下标为 0 的位置就是要找的元素，但是在计算复杂度的时候，需要考虑到最差情况，即看到最后一个位置的时候，才找到这个元素，因此至少执行数组长度这么多次的查找，才能找到；
  + 在一个有序数组（长度为 $N$）里查找，可以使用二分查找算法，最好情况下依然是 1 次就找到（中点位置），但是最坏情况下，例如中点的两个邻居，就得找 $\log N$（这个数值需要上取整，这里不深究）次；
+ 题目中的「最小」字眼很让人迷惑，我的理解是：把求解 `F` 的过程认为是**用最好的算法，即使是在最坏的运气下，为了准确得到结果，找到 `F` 这个值的实验的次数最少是多少**。

正是因为用「最好的算法」，谈「最少次数」才有意义，这一点是比较绕的。而最好的算法隐含在「动态规划」的推导过程中，是通过比较得出来的。显然这种最优化的问题，只问结果，不问过程，就是用「动态规划」去求解的。

### 分析题意

题目中只有一个限制：鸡蛋的个数。

+ 如果鸡蛋无穷多，相当于没有限制，由于 `F` 是一个确定的整数值，可以使用二分查找去做，二分查找是最好的算法；
+ 如果只有 1 个鸡蛋：由于一定要测出 `F` 值，只能从底层到高层，一层一层尝试去仍，直到这个鸡蛋破碎为止，破碎位置的楼层高度 $- 1$，就是 `F` 值。

那么，如果鸡蛋的个数有若干个，该怎么利用好这些鸡蛋，还能保证运气最坏的情况下实验次数最少，这就相当复杂了。李永乐老师的视频里面有说一些方案，这些方案人脑直接想是想不完全的，需要通过计算机编程的方法去计算。

### 方法：动态规划

动态规划，可以认为是一种打表格的方法（定义来自《算法导论》）。规划（Programming）本来的意思是表格，在学习的基础算法领域使用这个语义是非常贴切的，因此大家理解这个规划意思的时候，可以暂时不用把它和数学里的线性规划联系起来，我们做基础算法题的动态规划问题还远没有到用数学方法解「约束条件下线性目标函数的极值问题」的高度，即使 Programming 在线性规划里确实是这个意思，但是基础算法领域里的规划强调的是：在求解的过程中，记住结果，以后要用到的时候，直接使用而不必重复计算，即「空间换时间」。「背包问题」、「最长回文子串」、「最长公共子序列」、「编辑距离」这些问题的求解我们都会看到程序其实就是在填写一张表格。

如果没有学习「动态规划」，我们还有「递归」，然后发现重复子问题，使用「缓存」记住结果是非常自然的，这叫「记忆化递归」（或者「记忆化搜索」）。而「动态规划」还告诉了我们一种思路，可以从一个问题最初的样子去考虑它是如何一步一步得到最终的规模。

「动态规划」的两个思考方向：

1. 自顶向下求解，称之为「记忆化递归」：初学的时候，建议先写「记忆化递归」的代码，然后把代码改成「自底向上」的「递推」求解；
2. 自底向上求解，称之为「递推」或者就叫「动态规划」：在基础的「动态规划」问题里，绝大多数都可以从这个角度入手，做多了以后建议先从这个角度先思考，实在难以解决再考虑「记忆化递归」。

说明：《算法导论》上把「记忆化递归」也归为「动态规划」的概念里。不管是「记忆化递归」还是「动态规划」，在这中间很关键的点是：如何拆分问题。这就涉及到「状态」的定义，「状态」我个人的理解是：求解一个问题所处的阶段，这个定义是非常关键的，在解题的时候一定要定义清楚，不能是模糊不清的。

这里的约束只有鸡蛋的个数，因此，为了消除鸡蛋的个数对递推的过程中造成的影响，我们在设置状态的时候要在后面加上一个维度，这种做法叫消除「后效性」，是常见的套路。在「打家劫舍」问题一、问题三还有「股票」的 6 道问题用的就是这个技巧。一般而言，一个约束对应一个维度的状态。约束越多，状态的维数就越多（这里限于我的水平和经验，没有严格论证）。

#### 第 1 步：定义状态

`dp[i][j]`：一共**有 `i` 层楼梯**（注意：这里 `i` 不表示高度）的情况下，使用 `j` 个鸡蛋的最少实验的次数。

说明：

1. `i` 表示的是楼层的大小，**不是高度（第几层）的意思**，例如楼层区间 `[8, 9, 10]` 的大小为 $3$。
2. `j` 表示可以使用的鸡蛋的个数，它是约束条件。

第一个维度最先容易想到的是表示楼层的高度，**这个定义的调整是在状态转移的过程中完成的**。因为如果通过实验知道了鸡蛋的 `F` 值在高度区间  `[8, 9, 10]` 里，这个时候只有 1 枚鸡蛋，显然需要做 3 次实验，和区间的大小是相关的。

注意：这里我定义的维度顺序和官方解答的定义是反着的，我个人习惯将约束的那个条件，放置在后面的维度，表示消除后效性的意思。

#### 第 2 步：推导状态转移方程

推导状态转移方程经常做的事情是「分类讨论」，这里「分类讨论」的依据就是，在指定的层数里扔下鸡蛋，根据这个鸡蛋是否破碎，就把问题拆分成了两个子问题。

设指定的楼层为 `k`，`k >= 1` 且 `k <= i`：

+ 如果鸡蛋破碎，测试 `F` 值的实验就得在 `k` 层以下做（不包括 k 层），这里已经使用了一个鸡蛋，因此测出 `F` 值的最少实验次数是：`dp[k - 1][j - 1]`；
+ 如果鸡蛋完好，测试 `F` 值的实验就得在 `k` 层以上做（不包括 k 层），这里这个鸡蛋还能使用，因此测出 `F` 值的最少实验次数是：`dp[i - k][j]`，例如总共 8 层，在第 `5` 层扔下去没有破碎，则需要在 `[6, 7, 8]` 层继续做实验，因此区间的大小就是 `8 - 5  = 3`。

最坏情况下，是这两个子问题的较大者，由于在第 `k` 层扔下鸡蛋算作一次实验，`k` 的值在 $1 \le k  \le i$，对于每一个 `k` 都对应了一组值的最大值，取这些 `k` 下的最小值（最优子结构），因此：

$$
dp[i][j] = \min_{1 \le k  \le i} \left(\max(dp[k - 1][j - 1], dp[i - k][j]) + 1 \right)
$$

解释：

+ 由于仍那一个鸡蛋需要记录一次操作，所以末尾要加上 $1$；
+ 每一个新值的计算，都参考了比它行数少，列数少的值，这些值一定是之前已经计算出来的，这样的过程就叫做「状态转移」。

这个问题只是状态转移方程稍显复杂，但空间换时间，逐层递推填表的思想依然是常见的动态规划的思路。

#### 第 3 步：考虑初始化

一般而言，需要 `0` 这个状态的值，这里 `0` 层楼和 `0` 个鸡蛋是需要考虑进去的，它们的值会被后来的值所参考，并且也比较容易得到。

因此表格需要 `N + 1` 行，`K + 1` 列。

由于 `F` 值不会超过最大楼层的高度，要求的是最小值，因此初始化的时候，可以叫表格的单元格值设置成一个很大的数，但是这个数肯定也不会超过当前考虑的楼层的高度。

+ 第 0 行：楼层为 $0$ 的时候，不管鸡蛋个数多少，都测试不出鸡蛋的 `F` 值，故全为 $0$；
+ 第 1 行：楼层为 $1$ 的时候，$0$ 个鸡蛋的时候，扔 $0$ 次，$1$ 个以及 $1$ 个鸡蛋以上只需要扔 $1$ 次；
+ 第 0 列：鸡蛋个数为 $0$ 的时候，不管楼层为多少，也测试不出鸡蛋的 `F` 值，故全为 $0$，虽然不符合题意，但是这个值有效，它在后面的计算中会被用到；
+ 第 1 列：鸡蛋个数为 $1$ 的时候，这是一种极端情况，要试出 `F` 值，最少次数就等于楼层高度；

#### 第 4 步：考虑输出

输出就是表格的最后一个单元格的值 `dp[N][K]`。

#### 第 5 步：思考空间优化

看状态转移方程，当前单元格的值只依赖之前的行，**当前列和它左边一列的值**。可以状态压缩，让「列」滚动起来。但是「空间优化」的代码增加了理解的难度，我们这里不做。

**参考代码 1**：（超时，但超时的数据是规模大的数据，说明算法没有问题。）

* []

```Java
import java.util.Arrays;

public class Solution {

    public int superEggDrop(int K, int N) {

        // dp[i][j]：一共有 i 层楼梯的情况下，使用 j 个鸡蛋的最少实验的次数
        // 注意：
        // 1、i 表示的是楼层的大小，不是第几层的意思，例如楼层区间 [8, 9, 10] 的大小为 3，这一点是在状态转移的过程中调整的定义
        // 2、j 表示可以使用的鸡蛋的个数，它是约束条件，我个人习惯放在后面的维度，表示消除后效性的意思

        // 0 个楼层和 0 个鸡蛋的情况都需要算上去，虽然没有实际的意义，但是作为递推的起点，被其它状态值所参考
        int[][] dp = new int[N + 1][K + 1];

        // 由于求的是最小值，因此初始化的时候赋值为一个较大的数，9999 或者 i 都可以
        for (int i = 0; i <= N; i++) {
            Arrays.fill(dp[i], i);
        }

        // 初始化：填写下标为 0、1 的行和下标为 0、1 的列
        // 第 0 行：楼层为 0 的时候，不管鸡蛋个数多少，都测试不出鸡蛋的 F 值，故全为 0
        for (int j = 0; j <= K; j++) {
            dp[0][j] = 0;
        }

        // 第 1 行：楼层为 1 的时候，0 个鸡蛋的时候，扔 0 次，1 个以及 1 个鸡蛋以上只需要扔 1 次
        dp[1][0] = 0;
        for (int j = 1; j <= K; j++) {
            dp[1][j] = 1;
        }

        // 第 0 列：鸡蛋个数为 0 的时候，不管楼层为多少，也测试不出鸡蛋的 F 值，故全为 0
        // 第 1 列：鸡蛋个数为 1 的时候，这是一种极端情况，要试出 F 值，最少次数就等于楼层高度（想想复杂度的定义）
        for (int i = 0; i <= N; i++) {
            dp[i][0] = 0;
            dp[i][1] = i;
        }

        // 从第 2 行，第 2 列开始填表
        for (int i = 2; i <= N; i++) {
            for (int j = 2; j <= K; j++) {
                for (int k = 1; k <= i; k++) {
                    // 碎了，就需要往低层继续扔：层数少 1 ，鸡蛋也少 1
                    // 不碎，就需要往高层继续扔：层数是当前层到最高层的距离差，鸡蛋数量不少
                    // 两种情况都做了一次尝试，所以加 1
                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[k - 1][j - 1], dp[i - k][j]) + 1);
                }
            }
        }
        return dp[N][K];
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(N^2K)$，三层 `for` 循环，每层循环都是线性的；
+ 空间复杂度：$O(NK)$，表格的大小。

这里需要盯着「状态转移方程」使劲看：

$$
dp[i][j] = \min_{1 \le k  \le i} \left(\max(dp[k - 1][j - 1], dp[i - k][j]) + 1 \right)
$$

「状态转移方程」里最外层的变量是 `k`，它枚举了扔下鸡蛋的楼层的高度，这里它是自变量，将其余的 `i` 和 `j` 视为常数：

+ `dp[k - 1][j - 1]`：根据语义，`k` 增大的时候，楼层大小越大，它的值就越大；
+ `dp[i - k][j]`：根据语义，`k` 增大的时候，楼层大小越小，它的值就越小。

可以得出一个是单调不减的（`dp[k - 1][j - 1]`，下图红点），一个是单调不增的（`dp[i - k][j]`，下图绿星），并且它们的值都是整数。

我使用了一组数据，制作成图表（每次取数据都取最后一行最后一列的那个单元格计算的数据）。

情况 1：最低点只有 1 个点

![image.png](https://pic.leetcode-cn.com/eaefcee366542bb41757dd9b98ec9e61b3290da24ec11d617df358fe3f8bb0ac-image.png)

情况 2：最低点是若干个重合的点

![image.png](https://pic.leetcode-cn.com/5336c2dbf3717c3e455e0180ef487fbffc4e1ec2315e476161908ef343ebe507-image.png)

情况 3：最低点不重合，但是两边的值一样

![image.png](https://pic.leetcode-cn.com/08e0971dcb71e5a91485ff71d4d9e01af6f643bd5289d103737d14a7e8aac108-image.png)

（生成图表的代码在本题解末尾。）

从图上可以看出：**二者的较大值的最小点在它们交汇的地方。那么有没有可能不交汇，当然有可能（上面第 3 张图），二者较大值的最小者一定出现在画成曲线段交点的两侧，并且二者的差值不会超过 $1$，也就是如果没有重合的点，两边的最大值是一样的（从图上看出来的，没有严格证明），因此取左侧和右侧两点中的一点都可以，不失一般性，可以取左边的那个点的 `k`**。

也就是找到使得 `dp[i - k][j] <= dp[k - i][j - 1]` 最大的那个 `k` 值即可。这里使用二分查找算法。关键在于 `dp[i - k][j] > dp[k - i][j - 1]` 的时候，`k` 一定不是我们要找的，根据这一点写出二分的代码。

写对二分查找法的方法在第 35 题[题解](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/)，希望能对大家有帮助。

**参考代码 2**：

* []

```Java
import java.util.Arrays;

public class Solution {

    public int superEggDrop(int K, int N) {
        // dp[i][j]：一共有 i 层楼梯的情况下，使用 j 个鸡蛋的最少仍的次数
        int[][] dp = new int[N + 1][K + 1];
        
        // 初始化
        for (int i = 0; i <= N; i++) {
            Arrays.fill(dp[i], i);
        }
        for (int j = 0; j <= K; j++) {
            dp[0][j] = 0;
        }

        dp[1][0] = 0;
        for (int j = 1; j <= K; j++) {
            dp[1][j] = 1;
        }
        for (int i = 0; i <= N; i++) {
            dp[i][0] = 0;
            dp[i][1] = i;
        }

        // 开始递推
        for (int i = 2; i <= N; i++) {
            for (int j = 2; j <= K; j++) {
                // 在区间 [1, i] 里确定一个最优值
                int left = 1;
                int right = i;
                while (left < right) {
                    // 找 dp[k - 1][j - 1] <= dp[i - mid][j] 的最大值 k
                    int mid = left + (right - left + 1) / 2;
                    
                    int breakCount = dp[mid - 1][j - 1];
                    int notBreakCount = dp[i - mid][j];
                    if (breakCount > notBreakCount) {
                        // 排除法（减治思想）写对二分见第 35 题，先想什么时候不是解
                        // 严格大于的时候一定不是解，此时 mid 一定不是解
                        // 下一轮搜索区间是 [left, mid - 1]
                        right = mid - 1;
                    } else {
                        // 这个区间一定是上一个区间的反面，即 [mid, right]
                        // 注意这个时候取中间数要上取整，int mid = left + (right - left + 1) / 2;
                        left = mid;
                    }
                }
                // left 这个下标就是最优的 k 值，把它代入转移方程 Math.max(dp[k - 1][j - 1], dp[i - k][j]) + 1) 即可
                dp[i][j] = Math.max(dp[left - 1][j - 1], dp[i - left][j]) + 1;
            }
        }
        return dp[N][K];
    }
}
```

**复杂度分析**：

+ 时间复杂度：$O(NK \log N)$，其中一层循环变成二分查找，复杂度成为对数；
+ 空间复杂度：$O(NK)$，表格的大小。

把求解问题使用的表格打印出来，就是李老师视频里最后展现的那个表格。

**附录**：

Python 代码 1：

原始代码，增加了收集数据的代码。

* python

```python
class Solution:
    def superEggDrop(self, K: int, N: int) -> int:

        dp = [[i for j in range(K + 1)] for i in range(N + 1)]

        for j in range(K + 1):
            dp[0][j] = 0

        dp[1][0] = 0
        for j in range(K + 1):
            dp[1][j] = 1

        for i in range(N + 1):
            dp[i][0] = 0
            dp[i][1] = i
        
        data = []
        for i in range(2, N + 1):
            for j in range(2, K + 1):
                for k in range(1, i + 1):
                    # 把最后一行，最后一列的求解过程制作成图表
                    if i == N and j == K:
                        data.append([k, dp[k - 1][j - 1], dp[i - k][j]])
                    dp[i][j] = min(dp[i][j], max(dp[k - 1][j - 1], dp[i - k][j]) + 1)
        return dp[N][K], data
```

Python 代码 2：

使用测试用例得到展现散点图的数据。

* python

```python
solution = Solution()
K = 3
N = 14
res, data = solution.superEggDrop(K, N)
res
```

Python 代码 3：

封装到 `DataFrame` 里方便调用。

* python

```python
import pandas as pd

scatters = pd.DataFrame(data=data, columns=['k','dp[k - 1][j - 1]','dp[i - k][j]'])
```

Python 代码 4：

绘图。

* python

```python
import matplotlib.pyplot as plt


plt.figure(figsize=(10, 8))
plt.scatter(
    scatters['k'], scatters['dp[k - 1][j - 1]'], c='r', marker='o', s=200)
plt.scatter(scatters['k'], scatters['dp[i - k][j]'], c='g', marker='*', s=300)
plt.legend(loc='upper left', prop={'size': 18})

 
plt.xticks([i for i in range(len(data) + 1)]) 
plt.tick_params(labelsize=14) 
plt.title('$N = 14, K = 3$',size = 20)
plt.ylabel('dp value', size = 14)
plt.xlabel('$k$', size = 14)
plt.grid() 
plt.savefig("image.png")
```

在 `K = 10`、`N = 1000` 时的表格：

* shell

```shell
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
[0, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2]
[0, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3]
[0, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3]
[0, 6, 3, 3, 3, 3, 3, 3, 3, 3, 3]
[0, 7, 4, 3, 3, 3, 3, 3, 3, 3, 3]
[0, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4]
[0, 9, 4, 4, 4, 4, 4, 4, 4, 4, 4]
[0, 10, 4, 4, 4, 4, 4, 4, 4, 4, 4]
[0, 11, 5, 4, 4, 4, 4, 4, 4, 4, 4]
[0, 12, 5, 4, 4, 4, 4, 4, 4, 4, 4]
[0, 13, 5, 4, 4, 4, 4, 4, 4, 4, 4]
[0, 14, 5, 4, 4, 4, 4, 4, 4, 4, 4]
[0, 15, 5, 5, 4, 4, 4, 4, 4, 4, 4]
[0, 16, 6, 5, 5, 5, 5, 5, 5, 5, 5]
[0, 17, 6, 5, 5, 5, 5, 5, 5, 5, 5]
[0, 18, 6, 5, 5, 5, 5, 5, 5, 5, 5]
[0, 19, 6, 5, 5, 5, 5, 5, 5, 5, 5]
[0, 20, 6, 5, 5, 5, 5, 5, 5, 5, 5]
[0, 21, 6, 5, 5, 5, 5, 5, 5, 5, 5]
[0, 22, 7, 5, 5, 5, 5, 5, 5, 5, 5]
[0, 23, 7, 5, 5, 5, 5, 5, 5, 5, 5]
[0, 24, 7, 5, 5, 5, 5, 5, 5, 5, 5]
[0, 25, 7, 5, 5, 5, 5, 5, 5, 5, 5]
[0, 26, 7, 6, 5, 5, 5, 5, 5, 5, 5]
[0, 27, 7, 6, 5, 5, 5, 5, 5, 5, 5]
[0, 28, 7, 6, 5, 5, 5, 5, 5, 5, 5]
[0, 29, 8, 6, 5, 5, 5, 5, 5, 5, 5]
[0, 30, 8, 6, 5, 5, 5, 5, 5, 5, 5]
[0, 31, 8, 6, 6, 5, 5, 5, 5, 5, 5]
[0, 32, 8, 6, 6, 6, 6, 6, 6, 6, 6]
[0, 33, 8, 6, 6, 6, 6, 6, 6, 6, 6]
[0, 34, 8, 6, 6, 6, 6, 6, 6, 6, 6]
[0, 35, 8, 6, 6, 6, 6, 6, 6, 6, 6]
[0, 36, 8, 6, 6, 6, 6, 6, 6, 6, 6]
[0, 37, 9, 6, 6, 6, 6, 6, 6, 6, 6]
[0, 38, 9, 6, 6, 6, 6, 6, 6, 6, 6]
[0, 39, 9, 6, 6, 6, 6, 6, 6, 6, 6]
[0, 40, 9, 6, 6, 6, 6, 6, 6, 6, 6]
[0, 41, 9, 6, 6, 6, 6, 6, 6, 6, 6]
[0, 42, 9, 7, 6, 6, 6, 6, 6, 6, 6]
[0, 43, 9, 7, 6, 6, 6, 6, 6, 6, 6]
[0, 44, 9, 7, 6, 6, 6, 6, 6, 6, 6]
[0, 45, 9, 7, 6, 6, 6, 6, 6, 6, 6]
[0, 46, 10, 7, 6, 6, 6, 6, 6, 6, 6]
[0, 47, 10, 7, 6, 6, 6, 6, 6, 6, 6]
[0, 48, 10, 7, 6, 6, 6, 6, 6, 6, 6]
[0, 49, 10, 7, 6, 6, 6, 6, 6, 6, 6]
[0, 50, 10, 7, 6, 6, 6, 6, 6, 6, 6]
[0, 100, 14, 9, 8, 7, 7, 7, 7, 7, 7]
[0, 200, 20, 11, 9, 8, 8, 8, 8, 8, 8]
[0, 300, 24, 13, 10, 9, 9, 9, 9, 9, 9]
[0, 400, 28, 14, 11, 10, 9, 9, 9, 9, 9]
[0, 500, 32, 15, 11, 10, 10, 9, 9, 9, 9]
[0, 1000, 45, 19, 13, 11, 11, 11, 10, 10, 10]
```

