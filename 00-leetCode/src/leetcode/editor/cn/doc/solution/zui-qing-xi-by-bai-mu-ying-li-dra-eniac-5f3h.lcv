替换后的最长重复字符

滑动窗口在确定目标字符下的利用

本题要求在给定交换次数k的限制下，找到包含相同字母字符的最长子字符串的长度，这一类连续子串的最长长度问题，涉及到改换操作的情况，我们往往可以通过滑动窗口的方式来实现。考虑到很相像的一个问题，就是[第1004题](https://leetcode-cn.com/problems/max-consecutive-ones-iii/)，最大连续1的个数，那个题目比这个更加简易，因为那个题目只有0和1，给定可以把0换成1的情况的限制次数，显然就是利用cnt来记录操作次数，利用滑动窗口先移动j（窗口右界），每遇到0的情况就让cnt加一，当次数达到限制的时候，就自然地再移动左界i来收缩窗口，更新最大值。

这里附上那一题清晰的滑动窗口解法，也是非常经典的使用滑动窗口模板来实现的：

* 

```
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int n=nums.size();
        int i=0;
        int j=0;
        int res=0;
        int cnt=0;
        while(j<n){
            if(nums[j]==0)cnt++;
            while(cnt>k){
                if(nums[i]==0)cnt--;
                i++;
            }
            res=max(res,j-i+1);
            j++;
        }
        return res;
    }
};
```

那么这个问题可不可以也用这样的形式简单明了的滑动窗口来是实现呢。好像一开始看上去是不好实现的，因为字母不是只有像0和1那样只有两个，可以遇到0就记录，这里有26个大写英文字母，形成最后答案的那个字母字串是未知的，这个时候要想利用滑动窗口双指针的思想来解决问题，就需要像官解那样做一些繁琐复杂特殊的处理和编码，那在这里我们可以采取先确定目标字符，然后配合这个简易纯粹清晰明了的滑动窗口模板就可以轻松拿下了。复杂度就是O(26n)，其实还是O(n)，具体实现的时候我们可以先统计出现的字母，然后只循环考虑出现的字母情况，就可以避免很多无意义的n次循环了，在n很大的时候，影响是相当大的。

代码如下：

* 

```
class Solution {
public:
    int characterReplacement(string s, int k) {
        int n=s.size();
        int occurs[26]{0};
        for(auto& ch:s){
            if(occurs[ch-'A']==0)occurs[ch-'A']=1;
        }
        int res=0;
        for(int t=0;t<26;t++){
            if(!occurs[t])continue;
            char tar='A'+t;
            int i=0;int j=0;
            int cnt=0;
            while(j<n){
                if(s[j]!=tar)cnt++;
                while(cnt>k){
                    if(s[i]!=tar)cnt--;
                    i++;
                }
                res=max(res,j-i+1);
                j++;
            }
        }
        return res;
    }
};
```

很显然，这样的编码清晰易懂，而且非常容易理解，编码起来也是十分地顺畅，无论在笔试还是在面试中，根据人的记忆特点，这种方法和官解那种比起来，是最容易也是最有保证能够在随时随地地准确无误地写出来的，复杂度和官解的复杂度是完全一致的，虽然无可避免地是，在n很大的时候，并且字符串种26个字母都涉及到的时候，具体执行效率会有小的差距，但我觉得，瑕不掩瑜了。
